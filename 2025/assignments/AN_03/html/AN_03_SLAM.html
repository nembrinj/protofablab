<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Julien Nembrini">
<meta name="dcterms.date" content="2025-10-02">
<meta name="keywords" content="Human-IST, ProtoFab, LearningLab, UniFR">

<title>Introduction to ROS and Turtlebot3</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="AN_03_SLAM_files/libs/clipboard/clipboard.min.js"></script>
<script src="AN_03_SLAM_files/libs/quarto-html/quarto.js"></script>
<script src="AN_03_SLAM_files/libs/quarto-html/popper.min.js"></script>
<script src="AN_03_SLAM_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="AN_03_SLAM_files/libs/quarto-html/anchor.min.js"></script>
<link href="AN_03_SLAM_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="AN_03_SLAM_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="AN_03_SLAM_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="AN_03_SLAM_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="AN_03_SLAM_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#protofab-assignment-3-introduction-to-slam-and-navigation-with-the-turtlebot3" id="toc-protofab-assignment-3-introduction-to-slam-and-navigation-with-the-turtlebot3" class="nav-link active" data-scroll-target="#protofab-assignment-3-introduction-to-slam-and-navigation-with-the-turtlebot3">ProtoFab Assignment 3: Introduction to SLAM and navigation with the Turtlebot3</a>
  <ul class="collapse">
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#pre-requisites" id="toc-pre-requisites" class="nav-link" data-scroll-target="#pre-requisites">Pre-requisites</a></li>
  <li><a href="#hints" id="toc-hints" class="nav-link" data-scroll-target="#hints">Hints</a></li>
  <li><a href="#tasks" id="toc-tasks" class="nav-link" data-scroll-target="#tasks">Tasks</a>
  <ul class="collapse">
  <li><a href="#task-1-test-slam-mapping-in-simulation" id="toc-task-1-test-slam-mapping-in-simulation" class="nav-link" data-scroll-target="#task-1-test-slam-mapping-in-simulation">Task 1 – Test SLAM mapping in simulation</a></li>
  <li><a href="#task-2-test-robot-navigation-in-simulation" id="toc-task-2-test-robot-navigation-in-simulation" class="nav-link" data-scroll-target="#task-2-test-robot-navigation-in-simulation">Task 2 – Test robot navigation in simulation</a></li>
  <li><a href="#task-3-send-a-goal-to-the-robot-through-a-topic" id="toc-task-3-send-a-goal-to-the-robot-through-a-topic" class="nav-link" data-scroll-target="#task-3-send-a-goal-to-the-robot-through-a-topic">Task 3 – Send a goal to the robot through a topic</a></li>
  <li><a href="#task-4-create-a-controller-able-to-navigate-from-one-goal-to-another" id="toc-task-4-create-a-controller-able-to-navigate-from-one-goal-to-another" class="nav-link" data-scroll-target="#task-4-create-a-controller-able-to-navigate-from-one-goal-to-another">Task 4 – Create a controller able to navigate from one goal to another</a></li>
  <li><a href="#task-5-optional-create-a-map-of-the-project-space-with-the-real-robot-and-navigate-into-it" id="toc-task-5-optional-create-a-map-of-the-project-space-with-the-real-robot-and-navigate-into-it" class="nav-link" data-scroll-target="#task-5-optional-create-a-map-of-the-project-space-with-the-real-robot-and-navigate-into-it">Task 5 [Optional] Create a map of the Project Space with the real robot and navigate into it</a></li>
  </ul></li>
  </ul></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="../../AN_03_SLAM.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Introduction to ROS and Turtlebot3</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Julien Nembrini </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 2, 2025</p>
    </div>
  </div>
  
    
  </div>
  

<div>
  <div class="keywords">
    <div class="block-title">Keywords</div>
    <p>Human-IST, ProtoFab, LearningLab, UniFR</p>
  </div>
</div>

</header>


<section id="protofab-assignment-3-introduction-to-slam-and-navigation-with-the-turtlebot3" class="level1">
<h1>ProtoFab Assignment 3: Introduction to SLAM and navigation with the Turtlebot3</h1>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>This practical work focuses on learning the basic concepts of SLAM, navigation and planning through a series of small tasks involving ROS. Simlar to Assignment 2, each task consists of applying hands-on commands in the terminal to illustrate how ROS and Turtlebot3 work. You will be asked to code on Task 3 and 4.</p>
<p>In this practical work, you will perform the following tasks:</p>
<ul>
<li><p><strong>Task 1</strong> – Test SLAM mapping in simulation</p></li>
<li><p><strong>Task 2</strong> – Test robot navigation in simulation</p></li>
<li><p><strong>Task 3</strong> – Send a goal to the robot through a topic</p></li>
<li><p><strong>Task 4</strong> – Create a controller able to navigate from one goal to another <strong>(code on your own)</strong>.</p></li>
<li><p><strong>Task 5</strong> – [Optional] Create a map of the Project Space with the real robot and navigate into it</p></li>
</ul>
<p><u><strong>Learning objectives:</strong></u></p>
<p>At the end of the assignment, you should be able to</p>
<ul>
<li><p>Understand the practical implications of classical mobile robotics algorithms</p></li>
<li><p>Understand the use of callbacks to monitor the robot state</p></li>
<li><p>Use high-level topics to steer the robot</p></li>
<li><p>Have a base code canvas to develop your project</p></li>
</ul>
</section>
<section id="pre-requisites" class="level2">
<h2 class="anchored" data-anchor-id="pre-requisites">Pre-requisites</h2>
<ul>
<li><p>A working installation of ROS (ubuntu 20.04 + ROS noetic) (see AN01)</p></li>
<li><p>Basic understanding and hands-on experience of ROS workings and concepts (see AN02)</p></li>
</ul>
</section>
<section id="hints" class="level2">
<h2 class="anchored" data-anchor-id="hints">Hints</h2>
<ol type="1">
<li><p>When you switch between simulation and real robot do not forget to change your ‘~/.bashrc’ file AND to source it!</p></li>
<li><p>Make sure your map is complete. An uncomplete map can lead to problems by path planning.</p></li>
</ol>
</section>
<section id="tasks" class="level2">
<h2 class="anchored" data-anchor-id="tasks">Tasks</h2>
<section id="task-1-test-slam-mapping-in-simulation" class="level3">
<h3 class="anchored" data-anchor-id="task-1-test-slam-mapping-in-simulation">Task 1 – Test SLAM mapping in simulation</h3>
<p>This task is inspired from <a href="https://emanual.robotis.com/docs/en/platform/turtlebot3/slam/">this page</a> (switch to the Noetic tab) and will be conducted in simulation.</p>
<ol type="1">
<li><p>Switch to simulation and start a roscore</p>
<ul>
<li><p>If you have run the real robot previously, open a terminal and edit your '~/.bashrc' file to comment/uncomment the ROS_MASTER_URI and ROS_HOSTNAME variables to point to localhost (see AN02).</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>[localpc-terminal] nano ~/.bashrc</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>Do not forget to source it afterwards to make the change take effect!</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>[localpc-terminal] source ~/.bashrc</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>Start roscore.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>[localpc-terminal] roscore</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
</ul></li>
<li><p>Start the gazebo simulation.</p>
<ul>
<li><p>Open a new terminal and start the gazebo simulation with the simple world</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>[localpc-terminal] roslaunch turtlebot3_gazebo turtlebot3_world.launch</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
</ul></li>
<li><p>Start the SLAM service</p>
<ul>
<li><p>Open a new terminal and start the SLAM algorithm using GMapping.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>[localpc-terminal] roslaunch turtlebot3_slam turtlebot3_slam.launch</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>This should open rviz with the start of a map based on current LIDAR readings.</p></li>
</ul></li>
<li><p>Explore the environment to build the map.</p>
<ul>
<li><p>Open a new terminal and start the teleoperation (see AN02)</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>[localpc-terminal] roslaunch turtlebot3_teleop turtlebot3_teleop_key.launch</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>Explore the environment using the keys. Observe how the map is created as more information is available from the LIDAR and the robot odometry.</p></li>
<li><p>Make sure your map is complete, e.g.&nbsp;that all sides of the world’s obstacles have been mapped, before saving it.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>[localpc-terminal] cd ~/profab_ws/</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>[localpc-terminal] mkdir map    </span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>[localpc-terminal] rosrun map_server map_saver -f ~/profab_ws/map/simulation</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
</ul></li>
</ol>
<div>

</div>
<div class="quarto-layout-panel" data-layout-ncol="2">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/incomplete_map.png" class="img-fluid figure-img" style="width:50.0%" data-margin="auto"></p>
<figcaption>Incomplete map</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/complete_map.png" class="img-fluid figure-img" style="width:50.0%" data-margin="auto"></p>
<figcaption>Complete map</figcaption>
</figure>
</div>
</div>
</div>
</div>
</section>
<section id="task-2-test-robot-navigation-in-simulation" class="level3">
<h3 class="anchored" data-anchor-id="task-2-test-robot-navigation-in-simulation">Task 2 – Test robot navigation in simulation</h3>
<p>This task is inspired from <a href="https://emanual.robotis.com/docs/en/platform/turtlebot3/navigation/">this page</a> (switch to the Noetic tab).</p>
<p>Navigation is the class of algorithm used to bring a robot from the estimate of its current location to a point on the map. It will use the map information to plan a path that avoids known obstacles. During its movement, the robot will constantly update its location using AMCL (Adaptive Monte Carlo Localization) which uses multiple estimates of its position. We will first show the convergence to the correct position from an initial random estimate, and secondly test interactively the ros navigation algorithm.</p>
<ol type="1">
<li><p>Start roscore and gazebo</p>
<ul>
<li>If you haven’t stopped roscore and the gazebo simulation from Task 1 you can continue. Otherwise restart both of them following points 1 and 2 from Task 1.</li>
<li>Make sure the SLAM service is stopped</li>
</ul></li>
<li><p>Start the navigation service</p>
<ul>
<li><p>Open a new terminal and start the navigation services.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>[localpc-terminal] roslaunch turtlebot3_navigation turtlebot3_navigation.launch map_file:=/home/&lt;user&gt;/profab_ws/map/simulation_complete.yaml</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
</ul></li>
<li><p>The navigation service uses AMCL to locate the robot. It is a probabilistic model composed of multiple particles that each represent a possible position. The robot’s estimated position is then the average of these positions. To locate itself accurately, the robot can either update its position from an initial random situation or refine an initial estimate. To illustrate the iterative position refinement through the particles we will first randomly spread them over the map.</p>
<ul>
<li><p>Open a new terminal and tell the AMCL localization to spread the particles randomly over the map</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>[localpc-terminal] rosservice call /global_localization "{}"</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>Restart the teleoperation, move the robot around and observe how the particles tend to converge to the real position of the robot. Note the difficulty yielded by symmetries of the simulated world.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>[localpc-terminal] roslaunch turtlebot3_teleop turtlebot3_teleop_key.launch</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
</ul></li>
<li><p>When you start the navigation service, the RViz interface has a button to indicate a initial 2D pose estimate.</p>
<ul>
<li>Select the “2D pose estimation” button and then click on the map to indicate where the robot is and its orientation. Note how the particles spread around the robot to account for a possible imprecision in the estimation.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/2D_pose_estimate.png" class="img-fluid figure-img" style="width:35.0%" data-margin="auto"></p>
<figcaption>2D pose estimation</figcaption>
</figure>
</div>
<ul>
<li><p>Restart the teleoperation, move the robot around and observe again how the particles converge to the real position of the robot. Note that the initial estimate does not always circumvent the symmetry problem.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>[localpc-terminal] roslaunch turtlebot3_teleop turtlebot3_teleop_key.launch</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
</ul></li>
<li><p>Now that the robot is located on the map, it can use the map information to navigate to another location.</p>
<ul>
<li>Select the “2D nav goal” button and then click on the map to indicate where the robot should go to and its final orientation. The robot then plans its path and start moving towards the goal. Check the “local map” box (if not already) to observe the local planner path and cost map.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/2D_nav_goal.png" class="img-fluid figure-img" style="width:35.0%" data-margin="auto"></p>
<figcaption>2D navigation goal</figcaption>
</figure>
</div>
<ul>
<li><p>IMPORTANT: the robot will not react to a navigation goal order if it does not consider itself sufficiently located, or if the goal is not reachable.</p></li>
<li><p>If you see light gray traces on your map. There might be a problem with the costmap (used by the gloabl planner). Here is the command to reset the costmap</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>[localpc-terminal] rosservice call /move_base/clear_costmaps "{}"</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
</ul></li>
<li><p>Select a new goal before the robot reaches the current goal, and observe that it triggers replanning and movement of the robot towards the newly defined goal without first reaching the current goal.</p></li>
</ol>
<p>In the remaining of the semester, you do not need to reset the position estimate. Just use the “2D pose estimation” button, move the robot around a little to let it locate itself. You will then be able to send goals.</p>
</section>
<section id="task-3-send-a-goal-to-the-robot-through-a-topic" class="level3">
<h3 class="anchored" data-anchor-id="task-3-send-a-goal-to-the-robot-through-a-topic">Task 3 – Send a goal to the robot through a topic</h3>
<p>In this task we will use the RQt interface and the topic “/move_base_simple/goal” to send a goal to our robot.</p>
<ol type="1">
<li><p>Start roscore, gazebo, the navigation as in Task 2 and make sure the robot is well located on the map</p></li>
<li><p>Start rqt in a new terminal to monitor the topics</p>
<pre><code> ```default         
 [localpc-terminal] rqt
 ```</code></pre></li>
<li><p>Understand the pose estimation topic “/acml_pose”</p>
<ul>
<li><p>Open the topics monitor (Plugins <span class="math inline">\rightarrow</span> Topics <span class="math inline">\rightarrow</span> Topics Monitor)</p></li>
<li><p>Expand the “/acml_pose” topic. The message type is a “geometry_msgs/PoseWithCovarianceStamped” and its structure is as follows</p>
<ul>
<li>header
<ul>
<li>frame_id</li>
<li>seq</li>
<li>stamp</li>
</ul></li>
<li>pose
<ul>
<li>covariance</li>
<li>pose
<ul>
<li>orientation</li>
<li>position</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>The header contains a frame ID, a sequence number and a time stamp.</p></li>
<li><p>The covariance is a 6x6 matrix which represents the uncertainty about the position estimate with the columns/rows in order (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis). If your robot is well localized, the elements in this matrix should be small.</p></li>
<li><p>Position is a (x,y,z) vector, while orientation is a quaternion (x,y,z,w), which represents an orientation in space. Have a look at the <a href="https://wiki.ros.org/tf2/Tutorials/Quaternions">ROS documentation on quaternions</a>. The important information is that this quaternion is <em>normalized</em> (e.g.&nbsp;its norme is equal to 1)</p></li>
<li><p>Note the “/particlecloud” topic with 500 poses</p></li>
</ul></li>
<li><p>Send a goal to the robot</p>
<ul>
<li><p>Open the Message Publisher ((Plugins <span class="math inline">\rightarrow</span> Topics <span class="math inline">\rightarrow</span> Message Publisher)), select the topic “/move_base_simple/goal”, keep other fields as they are defined and press the + button.</p></li>
<li><p>Expand the topic. The message type is a “geometry_msgs/PoseStamped” and its structure is as follows</p>
<ul>
<li>header
<ul>
<li>frame_id</li>
<li>seq</li>
<li>stamp</li>
</ul></li>
<li>pose
<ul>
<li>pose
<ul>
<li>orientation</li>
<li>position</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>The only difference is that there is no covariance matrix because there is no uncertainty in the goal definition.</p></li>
<li><p>Expand the position field and set the goal position to (-2,0,0). Expand the orientation field and set the goal orientation to north (0,0,0,1).</p></li>
<li><p>IMPORTANT: expand the “frame_id” field and set it to “map”, otherwise your goal message will be ignored by the robot (one way to find this information is by monitoring the topic when manually assigning a goal as in Task 2).</p></li>
<li><p>Check the “/move_base_simple/goal” box for more than a second (because of 1 Hz frequency). Switch to rviz and observe the robot navigate to the goal, Switch to the terminal running the navigation to see the trace generated.</p></li>
</ul></li>
<li><p>Test with other goal positions and orientations</p>
<ul>
<li><p>Test with goal positions (0,0,0) and (2,0,0) and observe the robot reactions.</p></li>
<li><p>Test with goal orientations (0,0,1,0), (0,0,1,1), (0, 0, 0.7071068, 0.7071068) and observe the robot reactions.</p></li>
<li><p>Here is a simple <a href="https://www.andre-gaschler.com/rotationconverter/">converter</a> from Euler angles or axis-angle to quaternion.</p></li>
</ul></li>
</ol>
</section>
<section id="task-4-create-a-controller-able-to-navigate-from-one-goal-to-another" class="level3">
<h3 class="anchored" data-anchor-id="task-4-create-a-controller-able-to-navigate-from-one-goal-to-another">Task 4 – Create a controller able to navigate from one goal to another</h3>
<p>In this task, we will replace the RQt interface with a python script, which will additionally monitor whether the robot has reached the currently assigned goal to assign another and make the robot go back and forth between two goals.</p>
<ol type="1">
<li><p>Make sure you have roscore, gazebo simulation and the navigation running (task 2 points 1.and 2.)</p></li>
<li><p>Create the goal python controller and run it</p>
<ul>
<li><p>Create the file ``goal_controller.py’’ and open it in an editor (here VS code)</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>[localpc-terminal] cd ~/profab_ws/src/turtlebot3_profab/scripts</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>[localpc-terminal] touch goal_controller.py</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>[localpc-terminal] chomd +x goal_controller.py</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>[localpc-terminal] code goal_controller.py</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>Use the partial source code below for your script (you can copy-paste). First have a look at the code to understand its structure.</p></li>
<li><p>Look at the gotogoal(), function, the handle_robot_logic() callback function and its timer. It waits 2 seconds and sends a goal command on the “/move_base_simple/goal” topic.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># callback that handles the main robot logic every 0.1 second </span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="va">self</span>.timer <span class="op">=</span> rospy.Timer(rospy.Duration(<span class="fl">0.1</span>), <span class="va">self</span>.handle_robot_logic)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>...</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> gotogoal(<span class="va">self</span>,goal):</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.goal_status <span class="op">=</span> <span class="op">-</span><span class="dv">1</span>  <span class="co"># reset goal status</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.goal <span class="op">=</span> goal</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.goal.header.stamp <span class="op">=</span> rospy.Time.now()</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.goal_pub.publish(<span class="va">self</span>.goal)</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    rospy.loginfo(<span class="st">"New goal is sent to the robot:"</span>)</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    rospy.loginfo(<span class="va">self</span>.goal)</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a><span class="co">#This function callback handles the main robot logic every 0.1 second</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> handle_robot_logic(<span class="va">self</span>, timer_event):</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Issue a goal command after 2 seconds</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="va">self</span>.goaltimer <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.goaltimer <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.goaltimer <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.gotogoal(<span class="va">self</span>.goal1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>Modify you CMakeLists.txt file by adding the line in the INSTALL directive (~line 170) of the file.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>catkin_install_python(PROGRAMS scripts/goal_controller.py DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>Build your workspace</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>[localpc-terminal] cd ~/profab_ws/</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>[localpc-terminal] catkin_make</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>Run the ccontroller</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>[localpc-terminal] rosrun turtlebot3_profab goal_controller.py</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>The robot should get to the (2,0,0) goal</p></li>
</ul></li>
<li><p>Monitor the goal status and if the goal 1 is reached, switch to goal 2 (TODO 1). Hint: use a timer to wait a few seconds before issuing the goal command.</p></li>
<li><p>Monitor the current robot position and compute the euclidean distance to the goal. If reached a distance below 50cm switch to the other goal (TODO 2)</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/usr/bin/env python3</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> rospy</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> geometry_msgs.msg <span class="im">import</span> PoseStamped, PoseWithCovarianceStamped, Twist, Point</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> move_base_msgs.msg <span class="im">import</span> MoveBaseActionResult</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="co">##</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="co">## Exercise</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="co">## You need to fill the </span><span class="al">TODO</span><span class="co"> parts to implement your logic</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="co">##</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> GoalNavigation:</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>        rospy.init_node(<span class="st">'goal_controller'</span>, anonymous<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>        rospy.loginfo(<span class="st">"Goal controller has started"</span>)</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Do some cleanup on shutdown</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>        rospy.on_shutdown(<span class="va">self</span>.clean_shutdown)</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Publisher to goal commands</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.goal_pub <span class="op">=</span> rospy.Publisher(<span class="st">'/move_base_simple/goal'</span>, PoseStamped, queue_size<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Subscriber to goal result information (receives once a message when the robot arrived to its destination goal)</span></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.result_sub <span class="op">=</span> rospy.Subscriber(<span class="st">'/move_base/result'</span>, MoveBaseActionResult, <span class="va">self</span>.result_callback)</span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Subscriber to current position information</span></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.position_sub <span class="op">=</span> rospy.Subscriber(<span class="st">'/amcl_pose'</span>, PoseWithCovarianceStamped, <span class="va">self</span>.position_callback)</span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Initialize Pose message for goal commands    </span></span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a>        <span class="co"># This message will be used to send position (x,y,z) and orientation (quaternion) to the robot</span></span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.goal <span class="op">=</span> PoseStamped()</span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a>        <span class="co"># pre-define the two goals</span></span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.goal1 <span class="op">=</span> PoseStamped()</span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.goal1.header.frame_id <span class="op">=</span> <span class="st">'map'</span></span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.goal1.pose.position.x <span class="op">=</span> <span class="fl">2.0</span></span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.goal1.pose.orientation.z <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.goal2 <span class="op">=</span> PoseStamped()</span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.goal2.header.frame_id <span class="op">=</span> <span class="st">'map'</span></span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.goal2.pose.position.x <span class="op">=</span> <span class="op">-</span><span class="fl">2.0</span></span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.goal2.pose.orientation.z <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb19-42"><a href="#cb19-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-43"><a href="#cb19-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-44"><a href="#cb19-44" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.goal_status <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb19-45"><a href="#cb19-45" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.euclidean_distance <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb19-46"><a href="#cb19-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-47"><a href="#cb19-47" aria-hidden="true" tabindex="-1"></a>        <span class="co"># flag to send once initial goal</span></span>
<span id="cb19-48"><a href="#cb19-48" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.goaltimer <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb19-49"><a href="#cb19-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-50"><a href="#cb19-50" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Publisher to send velocity commands</span></span>
<span id="cb19-51"><a href="#cb19-51" aria-hidden="true" tabindex="-1"></a>        <span class="co"># used to stop the robot</span></span>
<span id="cb19-52"><a href="#cb19-52" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.cmd_vel_pub <span class="op">=</span> rospy.Publisher(<span class="st">'/cmd_vel'</span>, Twist, queue_size<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb19-53"><a href="#cb19-53" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.twist <span class="op">=</span> Twist()</span>
<span id="cb19-54"><a href="#cb19-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-55"><a href="#cb19-55" aria-hidden="true" tabindex="-1"></a>        <span class="co"># callback that handles the main robot logic every 0.1 second </span></span>
<span id="cb19-56"><a href="#cb19-56" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.timer <span class="op">=</span> rospy.Timer(rospy.Duration(<span class="fl">0.1</span>), <span class="va">self</span>.handle_robot_logic)</span>
<span id="cb19-57"><a href="#cb19-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-58"><a href="#cb19-58" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Main loop rate</span></span>
<span id="cb19-59"><a href="#cb19-59" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.rate <span class="op">=</span> rospy.Rate(<span class="dv">10</span>)  <span class="co"># 10 Hz</span></span>
<span id="cb19-60"><a href="#cb19-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-61"><a href="#cb19-61" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Callback function to process goal result data</span></span>
<span id="cb19-62"><a href="#cb19-62" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> result_callback(<span class="va">self</span>, msg):</span>
<span id="cb19-63"><a href="#cb19-63" aria-hidden="true" tabindex="-1"></a>        <span class="co">#rospy.loginfo("Goal result %s", msg.status.status)     </span></span>
<span id="cb19-64"><a href="#cb19-64" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.goal_status <span class="op">=</span> msg.status.status</span>
<span id="cb19-65"><a href="#cb19-65" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.goal_status <span class="op">==</span> <span class="dv">3</span>:</span>
<span id="cb19-66"><a href="#cb19-66" aria-hidden="true" tabindex="-1"></a>            rospy.loginfo(<span class="st">"Goal reached successfully"</span>)</span>
<span id="cb19-67"><a href="#cb19-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="va">self</span>.goal_status <span class="op">==</span> <span class="dv">4</span>:</span>
<span id="cb19-68"><a href="#cb19-68" aria-hidden="true" tabindex="-1"></a>            rospy.loginfo(<span class="st">"Goal was aborted by the action server"</span>)</span>
<span id="cb19-69"><a href="#cb19-69" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="va">self</span>.goal_status <span class="op">==</span> <span class="dv">5</span>:</span>
<span id="cb19-70"><a href="#cb19-70" aria-hidden="true" tabindex="-1"></a>            rospy.loginfo(<span class="st">"Goal has been rejected by the action server"</span>)</span>
<span id="cb19-71"><a href="#cb19-71" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="va">self</span>.goal_status <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb19-72"><a href="#cb19-72" aria-hidden="true" tabindex="-1"></a>            rospy.loginfo(<span class="st">"Goal is being processed"</span>)</span>
<span id="cb19-73"><a href="#cb19-73" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="va">self</span>.goal_status <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb19-74"><a href="#cb19-74" aria-hidden="true" tabindex="-1"></a>            rospy.loginfo(<span class="st">"Goal received, but not yet processed"</span>)</span>
<span id="cb19-75"><a href="#cb19-75" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="va">self</span>.goal_status <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb19-76"><a href="#cb19-76" aria-hidden="true" tabindex="-1"></a>            rospy.loginfo(<span class="st">"Goal status is pending"</span>)</span>
<span id="cb19-77"><a href="#cb19-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-78"><a href="#cb19-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-79"><a href="#cb19-79" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Callback function to process robot position data</span></span>
<span id="cb19-80"><a href="#cb19-80" aria-hidden="true" tabindex="-1"></a>    <span class="co"># This function will be called whenever a new amcl_pose message is received</span></span>
<span id="cb19-81"><a href="#cb19-81" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> position_callback(<span class="va">self</span>, msg):</span>
<span id="cb19-82"><a href="#cb19-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-83"><a href="#cb19-83" aria-hidden="true" tabindex="-1"></a>        rospy.loginfo(msg.pose.pose)</span>
<span id="cb19-84"><a href="#cb19-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-85"><a href="#cb19-85" aria-hidden="true" tabindex="-1"></a>        <span class="co"># </span><span class="al">TODO</span><span class="co"> 2 Calculate the euclidean distance to the goal </span></span>
<span id="cb19-86"><a href="#cb19-86" aria-hidden="true" tabindex="-1"></a>        <span class="co"># and use this information to switch goal whenever you are within 50cm of the goal</span></span>
<span id="cb19-87"><a href="#cb19-87" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Hint: you can use the self.goal variable to access the current goal position</span></span>
<span id="cb19-88"><a href="#cb19-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-89"><a href="#cb19-89" aria-hidden="true" tabindex="-1"></a>        rospy.loginfo(<span class="st">"distance to goal </span><span class="sc">%f</span><span class="st">"</span>,<span class="va">self</span>.euclidean_distance)          </span>
<span id="cb19-90"><a href="#cb19-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-91"><a href="#cb19-91" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> gotogoal(<span class="va">self</span>,goal):</span>
<span id="cb19-92"><a href="#cb19-92" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.goal_status <span class="op">=</span> <span class="op">-</span><span class="dv">1</span>  <span class="co"># reset goal status</span></span>
<span id="cb19-93"><a href="#cb19-93" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.goal <span class="op">=</span> goal</span>
<span id="cb19-94"><a href="#cb19-94" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.goal.header.stamp <span class="op">=</span> rospy.Time.now()</span>
<span id="cb19-95"><a href="#cb19-95" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.goal_pub.publish(<span class="va">self</span>.goal)</span>
<span id="cb19-96"><a href="#cb19-96" aria-hidden="true" tabindex="-1"></a>        rospy.loginfo(<span class="st">"New goal is sent to the robot:"</span>)</span>
<span id="cb19-97"><a href="#cb19-97" aria-hidden="true" tabindex="-1"></a>        rospy.loginfo(<span class="va">self</span>.goal)</span>
<span id="cb19-98"><a href="#cb19-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-99"><a href="#cb19-99" aria-hidden="true" tabindex="-1"></a>    <span class="co">#This function callback handles the main robot logic every 0.1 second</span></span>
<span id="cb19-100"><a href="#cb19-100" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> handle_robot_logic(<span class="va">self</span>, timer_event):</span>
<span id="cb19-101"><a href="#cb19-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-102"><a href="#cb19-102" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Issue a goal command after 2 seconds</span></span>
<span id="cb19-103"><a href="#cb19-103" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.goaltimer <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb19-104"><a href="#cb19-104" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.goaltimer <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb19-105"><a href="#cb19-105" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.goaltimer <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb19-106"><a href="#cb19-106" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.gotogoal(<span class="va">self</span>.goal1)</span>
<span id="cb19-107"><a href="#cb19-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-108"><a href="#cb19-108" aria-hidden="true" tabindex="-1"></a>        <span class="co"># </span><span class="al">TODO</span><span class="co"> 1 Check if the robot has reached its goal and is ready to issue a new goal</span></span>
<span id="cb19-109"><a href="#cb19-109" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Hint: use a timer to wait a few seconds before sending the command</span></span>
<span id="cb19-110"><a href="#cb19-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-111"><a href="#cb19-111" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Main loop. spin is blocking and only allows to processes callbacks</span></span>
<span id="cb19-112"><a href="#cb19-112" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> run(<span class="va">self</span>):</span>
<span id="cb19-113"><a href="#cb19-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-114"><a href="#cb19-114" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="kw">not</span> rospy.is_shutdown():</span>
<span id="cb19-115"><a href="#cb19-115" aria-hidden="true" tabindex="-1"></a>            rospy.spin()</span>
<span id="cb19-116"><a href="#cb19-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-117"><a href="#cb19-117" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> clean_shutdown(<span class="va">self</span>):</span>
<span id="cb19-118"><a href="#cb19-118" aria-hidden="true" tabindex="-1"></a>        rospy.loginfo(<span class="st">"Goal controller is shutting down."</span>)</span>
<span id="cb19-119"><a href="#cb19-119" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.twist <span class="op">=</span> Twist()</span>
<span id="cb19-120"><a href="#cb19-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-121"><a href="#cb19-121" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Send motion commands to motors</span></span>
<span id="cb19-122"><a href="#cb19-122" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.cmd_vel_pub.publish(<span class="va">self</span>.twist)</span>
<span id="cb19-123"><a href="#cb19-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-124"><a href="#cb19-124" aria-hidden="true" tabindex="-1"></a>        rospy.loginfo(<span class="st">"Robot stopped."</span>)</span>
<span id="cb19-125"><a href="#cb19-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-126"><a href="#cb19-126" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">'__main__'</span>:</span>
<span id="cb19-127"><a href="#cb19-127" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb19-128"><a href="#cb19-128" aria-hidden="true" tabindex="-1"></a>        controller <span class="op">=</span> GoalNavigation()</span>
<span id="cb19-129"><a href="#cb19-129" aria-hidden="true" tabindex="-1"></a>        controller.run()</span>
<span id="cb19-130"><a href="#cb19-130" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> rospy.ROSInterruptException:</span>
<span id="cb19-131"><a href="#cb19-131" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
</ol>
<p>Some more details about portions of the code above:</p>
<ul>
<li><p>Shebang (line 1, <code>#!/usr/bin/env python3</code>): every Python ROS&nbsp;node&nbsp;will have this declaration at the top. This first line makes sure your script is executed as a Python script.</p></li>
<li><p>Imports (lines 2-4): imports the necessary topic messages</p></li>
<li><p>Main GoalNavigation class :</p>
<ul>
<li><p>def init(self): define potential variables, initialize ros node and connect to topics (pub and sub) using callbacks.</p>
<p>Note the self.timer which defines a callback function which will be called every 100ms (see below).</p></li>
<li><p>def result_callback(self, msg): returns a result regarding the current goal command.</p></li>
<li><p>def position_callback(self, msg): returns an estimate of the current robot position.</p></li>
<li><p>def gotogoal(self,goal): sends a goal command on the “/move_base_simple/goal” topic.</p></li>
<li><p>def handle_robot_logic(self, timer_event): is called every 100ms and can be used to implement a finite state machine.</p></li>
</ul></li>
</ul>
<!-- 
    ```python
#!/usr/bin/env python3
import rospy
from geometry_msgs.msg import PoseStamped, PoseWithCovarianceStamped, Twist, Point
from move_base_msgs.msg import MoveBaseActionResult


##
## SOLUTION DO NOT GIVE TO STUDENTS
##

class GoalNavigation:
    def __init__(self):
        rospy.init_node('goal_controller', anonymous=True)
        rospy.loginfo("Goal controller has started")

        # Do some cleanup on shutdown
        rospy.on_shutdown(self.clean_shutdown)

        # Publisher to goal commands
        self.goal_pub = rospy.Publisher('/move_base_simple/goal', PoseStamped, queue_size=10)

        # Subscriber to goal result information (receives once a message when the robot arrived to its destination goal)
        self.result_sub = rospy.Subscriber('/move_base/result', MoveBaseActionResult, self.result_callback)

        # Subscriber to current position information
        self.position_sub = rospy.Subscriber('/amcl_pose', PoseWithCovarianceStamped, self.position_callback)


        # Initialize Pose message for goal commands    
        # This message will be used to send position (x,y,z) and orientation (quaternion) to the robot
        self.goal = PoseStamped()


        # pre-define the two goals
        self.goal1 = PoseStamped()
        self.goal1.header.frame_id = 'map'
        self.goal1.pose.position.x = 2.0
        self.goal1.pose.orientation.z = 1.0

        self.goal2 = PoseStamped()
        self.goal2.header.frame_id = 'map'
        self.goal2.pose.position.x = -2.0
        self.goal2.pose.orientation.z = 1.0


        self.goal_status = -1
        self.euclidean_distance = -1

        # flag to send once initial goal
        self.goaltimer = 20

        # flag to send once initial goal
        self.move_next_goal_timer = 20
        

        # Publisher to send velocity commands
        # used to stop the robot
        self.cmd_vel_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=10)
        self.twist = Twist()

        # callback that handles the main robot logic every 0.1 second 
        self.timer = rospy.Timer(rospy.Duration(0.1), self.handle_robot_logic)

        # Main loop rate
        self.rate = rospy.Rate(10)  # 10 Hz



    # Callback function to process goal result data
    def result_callback(self, msg):
        #rospy.loginfo("Goal result %s", msg.status.status)     
        self.goal_status = msg.status.status
        if self.goal_status == 3:
            rospy.loginfo("Goal reached successfully")
        elif self.goal_status == 4:
            rospy.loginfo("Goal was aborted by the action server")
        elif self.goal_status == 5:
            rospy.loginfo("Goal has been rejected by the action server")
        elif self.goal_status == 2:
            rospy.loginfo("Goal is being processed")
        elif self.goal_status == 1:
            rospy.loginfo("Goal received, but not yet processed")
        elif self.goal_status == 0:
            rospy.loginfo("Goal status is pending")


    # Callback function to process robot position data
    # This function will be called whenever a new amcl_pose message is received
    def position_callback(self, msg):

        rospy.loginfo(msg.pose.pose)
        
        # Calculate Euclidean distance to the goal
        self.euclidean_distance = ((msg.pose.pose.position.x - self.goal.pose.position.x) ** 2 + (msg.pose.pose.position.y - self.goal.pose.position.y) ** 2) ** 0.5

        rospy.loginfo("distance to goal %f",self.euclidean_distance)

    
    def is_at_goal(self):
        if self.goal_status == 3:
            return True
        return False
                        

    def gotogoal(self,goal):
        self.goal_status = -1  # reset goal status
        self.goal = goal
        self.goal.header.stamp = rospy.Time.now()
        self.goal_pub.publish(self.goal)
        rospy.loginfo("New goal is sent to the robot:")
        rospy.loginfo(self.goal)



    #This function callback handles the main robot logic every 0.1 second
    def handle_robot_logic(self, timer_event):
        
        # Issue a first move command after 2 seconds
        if self.goaltimer > 0:
            self.goaltimer -= 1
            if self.goaltimer == 0:
                self.gotogoal(self.goal1)
        else:
            # Check if the robot has reached its goal and is ready to issue a new goal
            if self.is_at_goal():
                rospy.loginfo("is at goal - wait for timer")

                if self.move_next_goal_timer > 0:
                        self.move_next_goal_timer -= 1
                        if self.move_next_goal_timer == 0:
                                        
                            rospy.loginfo("Go to next goal")
                            if self.goal == self.goal1:
                                self.gotogoal(self.goal2)
                            else:
                                self.gotogoal(self.goal1)

                            self.move_next_goal_timer = 20


    # Main loop. spin is blocking and only allows to processes callbacks
    def run(self):

        while not rospy.is_shutdown():
            rospy.spin()

    def clean_shutdown(self):
        rospy.loginfo("Goal controller is shutting down.")
        self.twist = Twist()

        # Send motion commands to motors
        self.cmd_vel_pub.publish(self.twist)

        rospy.loginfo("Robot stopped.")

if __name__ == '__main__':
    try:
        controller = GoalNavigation()
        controller.run()
    except rospy.ROSInterruptException:
        pass


    ```
-->
</section>
<section id="task-5-optional-create-a-map-of-the-project-space-with-the-real-robot-and-navigate-into-it" class="level3">
<h3 class="anchored" data-anchor-id="task-5-optional-create-a-map-of-the-project-space-with-the-real-robot-and-navigate-into-it">Task 5 [Optional] Create a map of the Project Space with the real robot and navigate into it</h3>
<ol type="1">
<li><p>Change the ROS_MASTER and ROS_HOSTNAME in your .bashrc to point on your ip address ```default<br>
# Settings to use the real robot (use your own <local_machine_ip>) export ROS_MASTER_URI=http://192.168.1.2:11311 export ROS_HOSTNAME=192.168.1.2</local_machine_ip></p>
<p># Settings to use the turtlebot3 in simulation (uncomment the two lines below) #export ROS_MASTER_URI=http://127.0.0.1:11311 #export ROS_HOSTNAME=127.0.0.1 ```</p></li>
<li><p>Source your .bashrc on <strong>all</strong> open terminals.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>[localpc-terminal] source ~/.bashrc</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>Turn on the robot. Make sure you are on the right wifi.</p></li>
<li><p>Ssh into the robot (the IP must be the one of your turtlebot3). Turtlebot3 OS - user: ubuntu, password: turtlebot.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>[localpc-terminal] ssh ubuntu@192.168.1.101</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>Update the robot bashrc (edit the file using nano editor). Update ROS_MASTER_URI variable in the .bashrc file with the value of your <em>localpc-ip</em>. Save, exit nano and then source your file.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>[turtlebot-terminal] nano ~/.bashrc         </span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>[turtlebot-terminal] source ~/.bashrc</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>Start roscore on your local machine (open a new terminal if necessary)</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>[localpc-terminal-1] roscore</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>Start turtlebot3_robot node on the robot. This establishes the connection between the robot and ROS and brings up all necessary drivers.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>[turtlebot-terminal] roslaunch turtlebot3_bringup turtlebot3_robot.launch</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>Start the SLAM service</p>
<ul>
<li><p>Open a new terminal and start the SLAM algorithm using GMapping.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>[localpc-terminal] roslaunch turtlebot3_slam turtlebot3_slam.launch</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>This should open rviz with the start of a map based on current LIDAR readings.</p></li>
</ul></li>
<li><p>Start teleop on your local machine (open a new terminal if necessary)</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>[localpc-terminal-2] roslaunch turtlebot3_teleop turtlebot3_teleop_key.launch</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>Explore the environment to build the map. Do not go move or turn too fast.</p></li>
</ol>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>