from django.contrib.auth.decorators import login_required
from django.shortcuts import render, redirect
from django.http import JsonResponse
from django.utils import timezone
from .models import QRCode
import qrcode
import base64
import io
import random
import string
import requests
from typing import Callable
from django.contrib.auth.models import User
from typing import Union
from django.contrib.auth.models import User
from django.http import HttpRequest, JsonResponse
from django.views.decorators.csrf import csrf_exempt
import random
from dotenv import load_dotenv
import os
import paho.mqtt.client as mqtt
from typing import NewType

load_dotenv(".env")

REAL_EXTERNAL_API_ENDPOINT = ("TRUE" == os.getenv("REAL_EXTERNAL_API_ENDPOINT"))
REAL_CAMERA_API_ENDPOINT =  ("TRUE" == os.getenv("REAL_CAMERA_API_ENDPOINT"))
CAMERA_API_ENDPOINT = os.getenv("CAMERA_API_ENDPOINT") 
MQTT_SERVER_HOST = os.getenv("MQTT_SERVER_HOST") 
MQTT_SERVER_PORT = int(os.getenv("MQTT_SERVER_PORT"))
mqttPubTopicScanner = "webapp_to_lock"
current_door_state = "unlocked"
temp_qr_codes = [None]

def change_door_state(new_door_state: str):
    """
    Changes the state of the door and publishes the new state to the MQTT scanner topic.

    Parameters:
    new_door_state (str): The desired state of the door ("unlocked" or "locked").
    """
    if new_door_state ==  "unlocked":
        client.publish(mqttPubTopicScanner, payload="unlocked", qos=1, retain=False)
        current_door_state = "unlocked"
    else:
        client.publish(mqttPubTopicScanner, payload="lock", qos=1, retain=False)
        current_door_state = "lock"

def pre_render_function(view_func: Callable) -> Callable:
    """
    Decorator function to modify the request context before rendering a view function.

    Parameters:
    view_func: The original view function.

    Returns:
    Callable: The wrapper function that modifies the request context.
    """
    def wrapper(request, *args, **kwargs):

        # API request logic
        if REAL_EXTERNAL_API_ENDPOINT:
            response = requests.get(EXTERNAL_PROJECT_API_ENDPOINT + '/is_door_close')
            data = response.json()
            is_door_close = data.get('is_door_close', False)
        else:
            is_door_close = bool(random.getrandbits(1))

        # Modify the request context based on the API response
        request.is_door_close = is_door_close

        return view_func(request, *args, **kwargs)
    return wrapper

def get_latest_qr_code(current_user: User) -> Union['QRCode', None]:
    """
    Retrieves the latest QR code generated by the current user within a specific time window.

    Parameters:
    current_user (User): The user object associated with the QR codes.

    Returns:
    Union[QRCode, None]: The latest QR code object generated by the current user within the specified time window, 
                         or None if no QR code is found.
    """
    threshold_time = timezone.now() - timezone.timedelta(seconds=30)
    latest_qr_code = QRCode.objects.filter(created_at__gte=threshold_time, user=current_user).order_by('-created_at').first()
    return latest_qr_code

def generate_random_string(length: int) -> str:
    """
    Generates a random string of a specified length.

    Parameters:
    length (int): The length of the random string to be generated.

    Returns:
    str: The randomly generated string.
    """
    characters = string.ascii_letters + string.digits
    return ''.join(random.choice(characters) for _ in range(length))


def turn_on_camera(request: HttpRequest) -> 'JsonResponse':
    """
    Send request to turn on the camera.

    Returns:
    JsonResponse: The JSON response indicating the status of the operation.

    """
    qr_code = temp_qr_codes[0]
    response = JsonResponse({})

    if REAL_CAMERA_API_ENDPOINT:
        camera_response = requests.get(CAMERA_API_ENDPOINT + '/turn_on').text
        qr_code = temp_qr_codes[0] 
        print(camera_response, " : " ,qr_code)

        if camera_response == qr_code:
            change_door_state('unlocked')
            return JsonResponse({'message': 'Camera turned on successfully', 'code' : camera_response})
        else:
            return JsonResponse({'message': 'Camera failed to turn on'})
    else:
        response.ok = True
    
    if response.ok:
        return JsonResponse({'message': 'Camera turned on successfully', 'code' : response})
    else:
        return JsonResponse({'error': 'Failed to turn on the camera'}, status=500) 

def generate_qr_code(user: User) -> 'QRCode':
    """
    Generates a QR code associated with the provided user.

    Parameters:
    user (User): The user object associated with the generated QR code.

    Returns:
    'QRCode': The generated QR code object.
    """
    random_string = generate_random_string(10)
    temp_qr_codes[0] = random_string
    qr_code = QRCode.objects.create(qr_value=random_string, user=user)
    return qr_code

def string_to_qr(qr_string: str) -> str:
    """
    Converts a given string into an image of a QR code.

    Parameters:
    qr_string (str): The string to be converted into a QR code.

    Returns:
    str: The base64-encoded image data representing the QR code.
    """
    qr = qrcode.QRCode(
        version=1,
        error_correction=qrcode.constants.ERROR_CORRECT_L,
        box_size=10,
        border=4,
    )
    # Use the random string as data
    qr.add_data(qr_string)
    qr.make(fit=True)
    
    # Create an image from the QR Code instance
    img = qr.make_image(fill_color="black", back_color="white")

    # Save the image to a BytesIO buffer
    buffer = io.BytesIO()
    img.save(buffer)
    img_data = base64.b64encode(buffer.getvalue()).decode()
    return img_data

@pre_render_function
@login_required
def index(request: HttpRequest) -> JsonResponse:
    """
    Renders the index page while handling user authentication and modifying the request context.

    Parameters:
    request (HttpRequest): The HTTP request object.

    Returns:
    JsonResponse: The JSON response containing the rendered index page data.
    """
    context = {}
    context['is_door_close'] = getattr(request, 'is_door_close', False)
    return render(request, 'qrgenerator/index.html', context)

@login_required
def generate_qr(request: HttpRequest) -> JsonResponse:
    """
    Generates a QR code and returns the image data along with remaining time.

    Parameters:
    request (HttpRequest): The HTTP request object.

    Returns:
    JsonResponse: The JSON response containing the QR code image data and remaining time.
    """
    existing_qr_code = get_latest_qr_code(request.user)
    if existing_qr_code:
        # Calculate the remaining time for the existing QR code
        remaining_time = (existing_qr_code.created_at + timezone.timedelta(seconds=30) - timezone.now()).total_seconds()
        return JsonResponse({'img_data': string_to_qr(existing_qr_code.qr_value), 'remaining_time': int(max(remaining_time, 0))})

    # Generate a new QR code
    qr_code = generate_qr_code(request.user)

    return JsonResponse({'img_data': string_to_qr(qr_code.qr_value), 'remaining_time': 30})

@login_required
def close_door(request: HttpRequest) -> JsonResponse:
    """
    Sends a request to an external API to close a door and returns the response.

    Parameters:
    request (HttpRequest): The HTTP request object.

    Returns:
    JsonResponse: The JSON response indicating the status of the door closure operation.
    """

    response = JsonResponse({})
    if REAL_EXTERNAL_API_ENDPOINT:
        change_door_state('locked')
        print("door is now locked")
    else:
        response.ok = True

    if response.ok:
        return JsonResponse({'message': 'Door closed successfully'})
    else:
        return JsonResponse({'error': 'Failed to close the door'}, status=500)